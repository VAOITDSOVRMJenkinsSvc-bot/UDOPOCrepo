using System;
using System.Linq;
using MCSPlugins;
using MCSUtilities2011;
using Microsoft.Xrm.Sdk;
using System.Collections.Generic;
using Microsoft.Xrm.Sdk.Query;
using VRM.Integration.UDO.Notes.Messages;
using VRMRest;
//using UDO.Model;
using System.ServiceModel;
using System.Diagnostics;
using UDO.LOB.Core;
/// <summary>
/// VIMT LOB Component for UDOcreateAwardAdjustment,createAwardAdjustment method, PluginRunner.
/// Code Generated by IMS on: 6/4/2015 9:39:25 AM
/// Version: 2015.06.02
/// </summary>
/// <param name=none></param>
/// <returns>none</returns>
namespace VRM.Integration.UDO.Notes.Plugins
{
    internal class DeleteNotesPreRunner : PluginRunner
    {
        bool _bypass = false; //bypass rules to be able to delete from legacy.
        bool _logSoap = false;
        bool _logTimer = false;
        string _pcrspid = "";
        string _uri = "";
        private const string _vimtRestEndpointField = "crme_restendpointforvimt";
        private CRMAuthTokenConfiguration _crmAuthTokenConfig;

        public DeleteNotesPreRunner(IServiceProvider serviceProvider)
            : base(serviceProvider)
        { }
        public override Entity GetPrimaryEntity()
        {
            return PluginExecutionContext.PreEntityImages["Pre"] as Entity;
        }
        public override Entity GetSecondaryEntity()
        {
            return PluginExecutionContext.PreEntityImages["Pre"] as Entity;
        }
        public override string McsSettingsDebugField
        {
            get { return "udo_notes"; }
        }
        internal void Execute(IServiceProvider serviceProvider)
        {
            try
            {
                #region Allow Force Delete
                var context = PluginExecutionContext;
                bool forcedelete = false;
                do
                {
                    if (context.MessageName.Equals("udo_note_forcedelete", StringComparison.InvariantCultureIgnoreCase))
                    {
                        forcedelete = true;
                        break;
                    }
                    context = context.ParentContext;
                } while (context != null);

                if (forcedelete) return;
                #endregion

                Trace("Starting delete note");
                Stopwatch txnTimer = Stopwatch.StartNew();
                var entity = GetPrimaryEntity();

                if (entity == null)
                {
                    throw new InvalidPluginExecutionException("Target entity is null");
                }

                var _veteranId = McsHelper.getEntRefID("udo_veteranid");
                Trace("_veteranId:" + _veteranId);

                var _PID = McsHelper.getStringValue("udo_participantid");
                Trace("_PID:" + _PID);

                var dtTime = McsHelper.getDateTimeValue("udo_dttime");
                Trace("dtTime:" + dtTime);

                var datetime = McsHelper.getStringValue("udo_datetime");
                Trace("datetime:" + datetime);

                var noteid = McsHelper.getStringValue("udo_legacynoteid");
                Trace("noteid:" + noteid);

                var nowminus24 = DateTime.Now;

                nowminus24 = nowminus24.AddHours(-24);

                if (!_bypass) {
                    if (dtTime<nowminus24 /* && dtTime>new DateTime(1900,1,2)*/)
                    {
                        throw new InvalidPluginExecutionException("customYou can't delete a note that is more 24 hours old.");
                    }
                    if (dtTime == null && noteid == null)
                    {   
                        throw new InvalidPluginExecutionException("customThere must be a note id or create date present in order to delete the note.");
                    }
                }

                getSettingValues();
                HeaderInfo HeaderInfo = GetHeaderInfo();
                var userid = McsHelper.getStringValue("udo_userid");
                Trace("userid:" + userid);
                Trace("_pcrspid:" + _pcrspid);  
                
                if (!_bypass && _pcrspid != userid)
                {
                    throw new InvalidPluginExecutionException("customOnly the original User can delete a note");
                }                

                // It has to be the same user, so we can keep the current stationNumber.
                var stationNumber = McsHelper.getStringValue("udo_ro");
                if (String.IsNullOrWhiteSpace(stationNumber)) stationNumber = HeaderInfo.StationNumber;

                var request = new UDODeleteNoteRequest()
                {
                    //MessageId = Guid.NewGuid().ToString(),
                    MessageId = PluginExecutionContext.CorrelationId.ToString(),
                    LegacyServiceHeaderInfo = HeaderInfo,
                    udo_User = _bypass ? userid : _pcrspid, 
                    udo_ClaimId = McsHelper.getStringValue("udo_claimid"),
                    udo_Note = McsHelper.getStringValue("udo_notetext"),
                    udo_ParticipantID = McsHelper.getStringValue("udo_participantid"),
                    udo_RO = stationNumber,
                    udo_dtTime = String.IsNullOrEmpty(datetime) ? dtTime.ToString() : datetime,
                    udo_LegacyNoteId = noteid,

                    Debug = McsSettings.getDebug,
                    LogSoap = _logSoap,
                    LogTiming = _logTimer,
                    UserId = PluginExecutionContext.InitiatingUserId,
                    OrganizationName = PluginExecutionContext.OrganizationName
                };

                //   Logger.WriteDebugMessage("Request Created");
                LogSettings _logSettings = new LogSettings()
                {
                    Org = PluginExecutionContext.OrganizationName,
                    ConfigFieldName = "RESTCALL",
                    UserId = PluginExecutionContext.InitiatingUserId,
                    callingMethod = "CreateNotesPre"
                };

                Uri uri = new Uri(_uri);


                if (string.IsNullOrEmpty(_uri))
                {
                    Trace("NO URI FOUND, cannot call VIMT");
                    return;
                }

                var response = Utility.SendReceive<UDODeleteNoteResponse>(uri, "UDODeleteNoteRequest", request,
                    _logSettings ,0, _crmAuthTokenConfig, TracingService);
                // Logger.WriteDebugMessage("back from EC");
                Trace("response:" + response.ExceptionOccured);
                txnTimer.Stop();

                TracingService.Trace("CreateNotes", txnTimer.ElapsedMilliseconds);

            }
            catch (FaultException<OrganizationServiceFault> ex)
            {
                PluginError = true;
                if (!ex.Message.StartsWith("custom"))
                {

                    Trace(ex.Message);
                    throw new InvalidPluginExecutionException(McsSettings.getUnexpectedErrorMessage);
                }
                throw new InvalidPluginExecutionException(ex.Message.Substring(6));

            }
            catch (Exception ex)
            {
                PluginError = true;
                if (!ex.Message.StartsWith("custom"))
                {

                    Trace(ex.Message);
                    throw new InvalidPluginExecutionException(McsSettings.getUnexpectedErrorMessage);
                }
                throw new InvalidPluginExecutionException(ex.Message.Substring(6));
            }
            finally
            {
                Trace("Entered Finally");
                SetupLogger();
                Trace("Set up logger done.");
                ExecuteFinally();
                Trace("Exit Finally");
            }
        }

        internal void getSettingValues()
        {
            _logTimer = McsSettings.GetSingleSetting<bool>("udo_noteslogtimer");
            _logSoap = McsSettings.GetSingleSetting<bool>("udo_noteslogsoap");

            _uri = McsSettings.GetSingleSetting<string>(_vimtRestEndpointField);

            string parentAppId = McsSettings.GetSingleSetting<string>("udo_oauthresourceid");
            string clientAppId = McsSettings.GetSingleSetting<string>("udo_oauthclientid");
            string clientSecret = McsSettings.GetSingleSetting<string>("udo_oauthclientsecret");
            string tenentId = McsSettings.GetSingleSetting<string>("udo_aadtenent");
            string apimsubscriptionkey = McsSettings.GetSingleSetting<string>("udo_ocpapimsubscriptionkey");
            string apimsubscriptionkeyS = McsSettings.GetSingleSetting<string>("udo_ocpapimsubscriptionkeysouth");
            string apimsubscriptionkeyE = McsSettings.GetSingleSetting<string>("udo_ocpapimsubscriptionkeyeast");

            //Create the token from settings
            _crmAuthTokenConfig = new CRMAuthTokenConfiguration
            {
                ParentApplicationId = parentAppId,
                ClientApplicationId = clientAppId,
                ClientSecret = clientSecret,
                TenantId = tenentId,
                ApimSubscriptionKey = apimsubscriptionkey,
                ApimSubscriptionKeyE = apimsubscriptionkeyE,
                ApimSubscriptionKeyS = apimsubscriptionkeyS
            };
        }

        internal HeaderInfo GetHeaderInfo()
        {          
            ColumnSet userCols = new ColumnSet("va_stationnumber", "va_wsloginname", "va_applicationname", "va_ipaddress", "va_pcrssn");
            Entity thisUser = OrganizationService.Retrieve("systemuser", PluginExecutionContext.InitiatingUserId, userCols);

            const string PIDIsNotAssignedForCrmUser = "Station Number is not assigned for CRM User.";
            const string vaPID = "va_pcrssn";

            if (!thisUser.Attributes.ContainsKey(vaPID))
                throw new Exception(PIDIsNotAssignedForCrmUser);



            const string stationNumberIsNotAssignedForCrmUser = "Station Number is not assigned for CRM User.";
            const string vaStationnumber = "va_stationnumber";

            if (!thisUser.Attributes.ContainsKey(vaStationnumber))
                throw new Exception(stationNumberIsNotAssignedForCrmUser);

            const string wsLoginIsNotAssignedForCrmUser = "WS Login is not assigned for CRM User.";
            const string vaWsloginname = "va_wsloginname";

            if (!thisUser.Attributes.ContainsKey(vaWsloginname))
                throw new Exception(wsLoginIsNotAssignedForCrmUser);

            const string applicationNameIsNotAssignedForCrmUser = "Application Name is not assigned for CRM User.";
            const string vaApplicationname = "va_applicationname";

            if (!thisUser.Attributes.ContainsKey(vaApplicationname))
                throw new Exception(applicationNameIsNotAssignedForCrmUser);

            const string clientMachineIsNotAssignedForCrmUser = "Client Machine is not assigned for CRM User.";
            const string vaIpAddress = "va_ipaddress";

            if (!thisUser.Attributes.ContainsKey(vaIpAddress))
                throw new Exception(clientMachineIsNotAssignedForCrmUser);

            _pcrspid = (string)thisUser[vaPID];

            var stationNumber = (string)thisUser[vaStationnumber];

            var loginName = (string)thisUser[vaWsloginname];

            var applicationName = (string)thisUser[vaApplicationname];

            var clientMachine = (string)thisUser[vaIpAddress];

            

            return new HeaderInfo
            {
                StationNumber = stationNumber,

                LoginName = loginName,

                ApplicationName = applicationName,

                ClientMachine = clientMachine,

                
            };
        }
    }
}